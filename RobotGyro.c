//#pragma config(StandardModel, "Autopilot Robot")
////*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


float get_angle(float off_x,float off_y,float distance)
{
    // in this case distance will be hypotenuse, so we can find angle using th
    if (off_x > 0 && off_y > 0){
        return acosf(off_x / distance) / pi * 180;
    }
    else if (off_x > 0 && off_y < 0){
        return -acosf(off_x / distance) / pi * 180;
    }
    else if ( off_x < 0 && off_y > 0){
        return 180 - acosf(off_y / distance) / pi * 180;
    }
    else if (off_x < 0 && off_y < 0){
        return -(90 + acosf(off_y / distance) / pi * 180);
    }
    else if (off_x == 0 && off_y < 0){
        return -90;
    }
    else if (off_x == 0 && off_y > 0){
        return 90;
    }
    else if (off_y == 0 && off_x < 0) {
        return -180;
    }
    else {
        if (off_y == 0 && off_x > 0) {
            return 0;
        };
    }
    return 0;
}

float get_distance(int off_x,int off_y)
{
	return sqrtf(off_x*off_x + off_y*off_y);
}


void rotate(float angle)
{
	resetGyro(gyroSensor);

	// left
	if(angle < 0)
	{
		while(angle < getGyroDegrees(gyroSensor))
		{
			setMotorSpeed(leftMotor,50);
			setMotorSpeed(rightMotor,-50);
		}
	}
	// right
	if(angle > 0)
	{
		while(angle < getGyroDegrees(gyroSensor))
		{
			setMotorSpeed(leftMotor,-50);
			setMotorSpeed(rightMotor,50);
		}
	}

}

void move(float distance)
{
	resetMotorEncoder(leftMotor);

	while(getMotorEncoder(leftMotor)<360*(distance/63*3.14))
	{
		setMultipleMotors(50,leftMotor,rightMotor);
	}
}

float move_to_next_coord(int c_x,int c_y,int n_x,int n_y,float r_angle)
{
    // get offset of current coord and next
    float off_x = (float)(n_x - c_x);
    float off_y = (float)(n_y - c_y);

    float distance = get_distance(off_x,off_y);
    float  angle = get_angle(off_x,off_y,distance);

    // change angle of robot
    r_angle = angle - r_angle;

    rotate(r_angle);
    move(distance);

    return angle;
}


task main()
{
	float r_angle = 0;

	r_angle = move_to_next_coord(0,0,0,20,r_angle);

	r_angle = move_to_next_coord(0,20,10,20,r_angle);
	//playSound(soundGarageDoorClose);
	r_angle = move_to_next_coord(10,20,20,40,r_angle);
	//playSound(soundGarageDoorClose);


	r_angle = move_to_next_coord(10,40,10,10,r_angle);
}
